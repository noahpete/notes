\lecture{21}{27 Mar. 10:30}{Diffie-Hellman Key Exchange, DDH Assumption, Public Key Encryption and CPA Security}

\section{Diffie-Hellman}
The key exchance problem occurs when two individuals seek to communicate over an insecure channel. The canonical story has \emph{Alice} and \emph{Bob} attempting to communicate over a channel being \emph{passively monitored} by an eavesdropper, \emph{Eve}.

\begin{definition}[Diffie-Hellman Protocol]
	\begin{enumerate}
		\,
		\item let Alice fix a large \hyperref[def:cyclicgroup]{cyclic group} \(G\) of known order \(q\). (\(|q| \approx \) security parameter).
		\item Alice discovers a generator \(g\) for \(G = \mathbf{Z} _{q+1}^*\) for \(q+1\) prime. In other words, Alice finds a number \(g\) that enumerates all elements of the group \(G\) when raised to the powers \(\left\{ 0, 1, \ldots , q - 1 \right\} \).
		\item Alice chooses random \(a \gets \mathbb{Z} _q\), let \(\mathcal{A} = g^a \in G\).
		\item Alice sends \(\mathcal{A} = g^a, g\)  to Bob over the insecure channel. Eve has access to this information.
		\item Bob receives the message and chooses a random \(b \gets \mathbb{Z} _q\) and sends \(\mathcal{B} = g^b \in G\) back to Alice.
		\item Alice and Bob both calculate \(\mathcal{K} = (g^a)^b = (g^b)^a = g^{ab}\) as their shared secret key.  
	\end{enumerate}
\end{definition}

An eavesdropper will have to take \emph{discrete log} to break this scheme (to find \(a\) or \(b\)). Formally, the security of this scheme is based on \textbf{DDH: Decisional Diffie-Hellman Assumption}.

\begin{definition}[Decisional Diffie-Hellman Assumption (DDH)]
	DDH holds for a group \(G = \langle g \rangle \) (i.e. \(G\) is \emph{generated} by \(g\)) if \[(g, g^a, g^b, g^{ab}) \in G^4\] is indistinguishable (for \(a, b \gets \mathbb{Z} _q, q = |G|\)) from \[(g, g^a, g^b, g^c), \text{ where }\: c \gets \mathbf{Z} _q\]
\end{definition}
\begin{remark}
	Key derivation can simply be an algorithm for turning a group element into a random bit-string.
\end{remark}

\section{Modeling Public Key Encryption}
We want to have a protocol (Gen, Enc, Dec) that can \emph{directly} handle public key encryption. We can model this analogously to EAV/CPA security, just in a public key setting:

\begin{figure}[H]
	\centering
	\incfig[0.45]{pubeavcpa}
	\caption{Analog of EAV/CPA security in the context of public keys.}
	\label{fig:pubeavcpa}
\end{figure}

\begin{definition}[Public Key CPA (EAV) Secure Scheme]
	For our \textbf{CPA secure public key scheme} we have:
	\begin{itemize}
		\item \(\mathrm{Gen}(1^n): \text{outputs } (k_p, k_s)\)
		\item \(\mathrm{Enc}(k_p, m \in M): \text{outputs ciphertext }c\)
		\item \(\mathrm{Dec}(k_s, c): \text{outputs } m \in M \text{(or fail "\(\perp\)")} \)  
	\end{itemize}
	We analyze it's correctness. For \((k_p, k_s) \gets \mathrm{Gen}(1^n)\), we always have \(\forall m \in M\):
	\[
		\mathrm{Dec}(k_s, \mathrm{Enc}(k_p, m)) = m
	\] 
\end{definition}
\begin{remark}
	Note that for the first time, our Gen function outputs two \emph{related} random keys, not just one private random string.
\end{remark}

Just like previous instances of security, we can define public key CPA security in the context of a game. Here we have adversary \(\mathcal{A} \) against \(\Pi = (\mathrm{Gen, Enc, Dec})\). Note that unlike the original CPA game, in this scenario the adversary only prompts the oracle once since the \emph{adversary can encrypt messages of their own}.

\begin{figure}[H]
	\centering
	\incfig[0.78]{pubcpasec}
	\caption{The public key CPA game.}
	\label{fig:pubcpasec}
\end{figure}

\begin{definition}[Public CPA Security]
	A public key encryption scheme \(\Pi\) as defined above is secure if \(\forall\) p.p.t. \(\mathcal{A} \):
	\[
		\mathbf{Adv}_\Pi (\mathcal{A}) \coloneqq \left| 
			\Pr_{(k_p, k_s) \gets \mathrm{Gen}(1^n)} (\mathcal{A}^{\mathcal{O}_{k_p, 0} (.,.)}(k_p)=1) -
		  \Pr_{(k_p, k_s) \gets \mathrm{Gen}(1^n)} (\mathcal{A}^{\mathcal{O}_{k_p, 1} (.,.)}(k_p)=1)
		\right| =
		\mathrm{negl}(n).
	\]
\end{definition}
\begin{remark}
	The number of queries to the LR oracle, \(\mathcal{O} \) doesn't matter. I.e. if we have EAV-security allowing \(\mathcal{A} \) to query the oracle once, then we have security even if multiple queries are allowed.
\end{remark}

\begin{proof}
	To show that \(\textit{one-query public CPA security} \implies \textit{many query public CPA security}\) we are essentially showing that
	\[
		\textit{public EAV security} \implies \textit{public CPA security}.
	\]
	We prove this by proposing a new adversary, \(\mathcal{A} \), that is capable of breaking a many-query CPA scheme, and then using this adversary to break the single-query EAV scheme. \par

	Imagine a many-query attacker, \(\mathcal{A} \) that makes up to \(q: \poly (n)\) queries. Consider the following worlds:
	\begin{enumerate}[label=(\roman*)]
		\item \emph{Hybrid 0}: All queries answered by \(c \gets Enc_{k_p}(m_0)\).
		\item \emph{Hybrid 1}: First query \((m_0, m_1)\) answered by \(c \gets Enc_{k_p}(m_1)\), then \(Enc_{k_p}(m_0)\) thereafter.
		\item \emph{Hybrid 2}: First \textbf{two} queries are answered by \(c \gets Enc_{k_p}(m_1)\), then \(Enc_{k_p}(m_0)\) thereafter.
		\item \emph{Hybrid q}: All queries answered by \(c \gets Enc_{k_p}(m_1)\) 
	\end{enumerate}

	These hyrbid worlds reflect the \emph{left} and \emph{right} worlds as follows:
	\begin{enumerate}[label=(\roman*)]
		\item \textbf{Left world}: equivalent to \(Hyb_0\): all queries to the LR oracle are answered by \(c \gets Enc_{k_p}(m_0)\).
		\item \textbf{Right world}: equivalent to \(Hyb_q\): all queries answered by \(c \gets Enc_{k_p}(m_1)\).
	\end{enumerate}

	We can use the idea that if an adversary, \(\mathcal{A} \) can distinguish between the left and right worlds, they must be able to distinguish between the \(i\)th hybrid world and the \(i+1\)th hybrid world where the \(i\)th hybrid world is defined as
	\begin{align*}
		HybridWorld_i &= \vcenter{\hbox{First $i$ queries of $(m_0, m_1)$ answered by $c \gets Enc_{k_p}(m_1)$,}} \\
		&\quad \vcenter{\hbox{\: \: \: \: \: \: \: then $c \gets Enc_{k_p}(m_0)$ thereafter}}.
	\end{align*}
	
	We first note that the difference between \(Hyb_{i - 1}\) and \(Hyb_i\) is only in how the \(i\)th query is answered. We can build a "simulator" \(\mathcal{S}_i^{\mathcal{O}}(k_p)\) that gets \emph{one query} and simulates either \(Hyb_{i - 1}\) or \(Hyb_i\) depending on \(b\).

	\begin{figure}[H]
		\centering
		\incfig[1]{onemanycpa}
		\caption{A simulator that wins pEAV game using an adversary that wins the pCPA game.}
		\label{fig:onemanycpa}
	\end{figure}

	Upon the \(j^\text{th} \) query of \(\mathcal{A} \) \((m_0^j, m_1^j)\):
	\begin{itemize}
		\item if \(j < i\), \(S_i\) runs \(c^j \gets Enc_{k_p}(m_1^j)\).
		\item if \(j > i\), \(S_i\) runs \(c^j \gets Enc_{k_p}(m_0^j)\).
		\item if \(j == i\), \(S_i\) queries its LR oracle and gives the result to \(\mathcal{A} \).
	\end{itemize}
	
	Consider the two cases where \(S_i\) is in the worlds:
	\begin{enumerate}[label=(\roman*)]
		\item \emph{Left world} \((b=0)\): then we are simulating \(Hyb_{i-1}\).
		\item \emph{Right world} \((b=1)\): then we are simulating \(Hyb_i\). 
	\end{enumerate}

	By the \textbf{triangle inequality},
	\begin{align*}
		\mathbf{Adv}_\Pi^{CPA} =& \left|
			\Pr(\mathcal{A} = 1 \text{ in } Hyb_0) -
			\Pr(\mathcal{A} = 1 \text{ in } Hyb_q)
		\right| \\
		=& |
			\Pr(\mathcal{A} = 1 \text{ in } Hyb_0) -
			\Pr(\mathcal{A} = 1 \text{ in } Hyb_1) + \\
			&\Pr(\mathcal{A} = 1 \text{ in } Hyb_1) -
			\Pr(\mathcal{A} = 1 \text{ in } Hyb_2) + \\
			&\ldots \: - \Pr(\mathcal{A} = 1 \text{ in } Hyb_q)
		| \\
		\leq& \sum_{i=1}^q \mathbf{Adv}_\Pi^\text{Single CPA} (\mathcal{S}_i) = q \cdot \mathrm{negl}(n) = \mathrm{poly}(n) \cdot \mathrm{negl}(n) = \mathrm{negl}(n).
	\end{align*}

	Thus, by assuming we had single-query (pEAV) security we have concluded we also have multi-query (pCPA) security. If we didn't have multi-query security, you could use a multi-query attacker to make a single-query attacker (contradicting the assumption that we are single-query secure).
\end{proof}

